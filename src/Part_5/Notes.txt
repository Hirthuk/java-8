PreDefined Functional Interfaces

This Pre-defined Functional Interfaces are used well with the Stream API. Which help us to achieve the
functional programming.

Functional Interfaces package is java.util.function
All other Functional Interfaces in this package is derived from this below four FI.
Most Commonly used Functional Interfaces
1) Function
2) Consumer
3) Supplier
4) Predicate

Function Functional Interface:

Perfect ğŸ‘Œ hereâ€™s your **short and clear â€œFunction Functional Interfaceâ€ note** â€” written in your style, with everything connected so you can easily remember ğŸ‘‡

---

## ğŸ§© **Function Functional Interface (java.util.function.Function)**

### ğŸ”¹ **What it is**

`Function<T, R>` is a **Functional Interface** in Java 8 that **takes one input (T)** and **returns one output (R)**.
Itâ€™s mainly used for **data transformation** â€” converting one type of data into another.

---

### ğŸ”¹ **Syntax**

```java
Function<T, R> functionName = (input) -> { return output; };
```

* `T` â†’ Input type
* `R` â†’ Return type
* `(input)` â†’ Input parameter
* `-> { return output; }` â†’ Lambda expression (method body)

---

### ğŸ”¹ **Example**

```java
Function<String, Integer> lengthFinder = (str) -> str.length();
System.out.println(lengthFinder.apply("Hello")); // Output: 5
```

**Explanation:**

* `Function<String, Integer>` â†’ input is String, output is Integer
* `(str) -> str.length()` â†’ Lambda defines the logic
* `.apply("Hello")` â†’ calls the function and passes "Hello" as input

---

### ğŸ”¹ **Connection with Lambda**

* `Function` has **one abstract method** â†’ `R apply(T t);`
* Lambda expression provides the **implementation** for that method.
* So, instead of creating a class that implements `Function`, we can directly write logic using Lambda.

---

### ğŸ”¹ **Method Reference Example**

We can also use **method reference** instead of Lambda:

```java
Function<String, String> toUpper = String :: toUpperCase;
System.out.println(toUpper.apply("java")); // Output: JAVA
```

---

### ğŸ”¹ **Common Methods**

| Method                     | Description                                        |
| -------------------------- | -------------------------------------------------- |
| `apply(T t)`               | Executes the function logic                        |
| `andThen(Function after)`  | Runs another function **after** current one        |
| `compose(Function before)` | Runs another function **before** current one       |
| `identity()`               | Returns a function that returns its input as it is |

This apply() method is the abstract method of Function Functional Interface. The Lambda expression or method
reference to define will be called using this apply abstract method.

Other Methods are default and static methods of the Function Functional Interface.

andThen(Function after) -> Runs another function **after** current one

This means you can have one Function FI instance that does something.. after is completes you want to
execute another FUnction FI instance(Important only takes FUNCTION FI instance) -> Implemented in code

compose(Function before) is quite opposite to andThen default function.

It will execute the function inside the compose function and then that value will be passed to the
first function.

âœ… **`Function.identity()` â€” Short Notes**

* **Definition:**
  Itâ€™s a **static method** in the `Function` interface that returns a **function which always returns its input argument**.

Since it is a static method we will calling using Function.identity();
* **Syntax:**

  ```java
  Function<T, T> func = Function.identity();
  ```

* **Meaning:**
  It acts as a **â€œdo nothingâ€** function â€” whatever input you give, the same is returned.

* **Example:**

  ```java
  Function<String, String> same = Function.identity();
  System.out.println(same.apply("Sharan")); // Output: Sharan
  ```

* **Use Case:**
  ğŸ”¹ When you need a *default* function in a pipeline or stream that doesnâ€™t transform data.
  ğŸ”¹ Common in **Stream API**:

  ```java
  map(Function.identity())   // keeps elements as-is
  ```

**In short:**
ğŸ‘‰ `Function.identity()` = `x -> x` (returns input unchanged).

