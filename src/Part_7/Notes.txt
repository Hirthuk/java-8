# **Stream API ‚Äî Short Notes**

* **Stream** is a **wrapper over a data source** (like List, Set, Array, etc.) used for processing data in a pipeline.
* Stream is **not a data structure**; it is only a **view** to process the data.
* Stream is an **Interface** in the `java.util.stream` package.
* Stream **does NOT change the original data source** ‚Äî it is *non-mutating*.
* Stream supports **functional-style operations** (map, filter, reduce).
* Stream can work in **sequence** or **parallel** (`parallelStream()`).
* Stream is used mostly with **Collections**, Arrays, Files, or any data source.
* Stream operations are of two types:
  ‚úî **Intermediate operations** ‚Üí return a new Stream (lazy)
  ‚úî **Terminal operations** ‚Üí end the Stream and return a result
* Stream uses **lambda expressions + functional interfaces** internally.
* Stream makes code **clean, fast, and more readable**.

Stream Instance/Object Initialization ways - Implemented

Here is the **clean, short, interview-ready note** ‚Äî **without code** ‚Äî in the same format you used.
I also added **all possible ways** to initialize a Stream.

---

# **Stream Instance/Object Initialization ‚Äî Short Notes**

### **1) Using Collection Object**

* Any Collection (List, Set, etc.) can create a Stream using the `stream()` method.

---

### **2) Using Array**

* Arrays can be converted into Streams using `Arrays.stream()`.

---

### **3) Using Stream.of()**

* Directly creates a Stream from one or more values.
* Most commonly used for quick Stream creation.

---

### **4) Using Stream.generate()**

* Creates an **infinite stream** using a **Supplier Functional Interface**.
* Useful for generating repeated or random values.

---

### **5) Using Stream.builder()**

* Uses the **Builder Design Pattern** to add values step-by-step and finally build the Stream.

---

### **6) Creating an Empty Stream**

* Useful when you want a Stream with no elements (placeholder or fallback case).

---

### **7) Using Stream.iterate()**

* Creates a sequential infinite Stream by repeatedly applying a function.
* Useful for series generation (e.g., numbers, patterns).

---

### **8) Using Files.lines()** *(File-based stream)*

* Reads lines of a file as a Stream of Strings.
* Useful in file processing pipelines.

---

### **9) Using Pattern.splitAsStream()** *(String split as stream)*

* Converts a String into a Stream by splitting using a regex pattern.

---

### **10) Using Stream.concat()**

* Combines two Streams into a single Stream.

---

# ‚≠ê Final Summary (Very Short)

**Ways to Initialize a Stream:**

1. Using Collection (`stream()`)
2. Using Array (`Arrays.stream()`)
3. Using Values (`Stream.of()`)
4. Infinite Stream (`Stream.generate()`)
5. Builder Pattern (`Stream.builder()`)
6. Empty Stream (`Stream.empty()`)
7. Iteration Stream (`Stream.iterate()`)
8. File lines (`Files.lines()`)
9. Regex split (`Pattern.splitAsStream()`)
10. Concatenate Streams (`Stream.concat()`)


Stream Operations

Intermediate operations
Terminal Operations

Intermediate Operations

Intermediate Operations methods on stream always return as another stream object.
In that case we can all multiple intermediate operations on same stream as chain of methods
This is called pipelined on same stream source

Intermediate operations are invoked only once when we invoke terminal operations.

Terminal Operations

We can call only once one terminal method on any stream instance
When we call terminal method we will get the result immediately with all pipelined methods.


---

# ‚úÖ **Most Used Stream Operations (Java 8)**

---

# **üî∑ Intermediate Operations (return Stream)**

> **Lazy** ‚Üí executes only when terminal op is called.

### **1) filter(Predicate)**

Selects elements that satisfy a condition.
*Ex:* keep only even numbers.

### **2) map(Function)**

Transforms each element into another value.
*Ex:* convert String ‚Üí length.

mapToInt(Integer :: intValue) -> Converts to Integer to int

### **3) flatMap(Function)**

Flattens nested structures.
*Ex:* List<List<Integer>> ‚Üí Stream<Integer>.

flatMap(): This is an intermediate operation in Java Streams that takes a Function as an argument.
This function is applied to each element of the input stream, and each application of the function is
expected to produce a new Stream.
flatMap() then takes all these individual streams and concatenates them into a single, flattened stream.

### **4) sorted()**

Sorts elements in natural order.

### **5) sorted(Comparator)**

Sorts using custom logic.

### **6) distinct()**

Removes duplicate elements.

### **7) limit(n)**

Takes only the first *n* elements.

### **8) skip(n)**

Skips the first *n* elements.

### **9) peek(Consumer)**

Used for debugging (like printing during pipeline).
Doesn‚Äôt modify elements.

### **10) mapToInt / mapToLong / mapToDouble**

Converts object stream ‚Üí primitive stream.

---

# **üî∑ Terminal Operations (end of stream pipeline)**

> **Executes all intermediate operations** and produces result.

### **1) forEach(Consumer)**

Applies an action for each element.
*Ex:* print elements.

### **2) collect(Collector)**

Converts stream ‚Üí List, Set, Map, etc.
Most used with `Collectors.toList()`.

### **3) toArray()**

Converts stream ‚Üí array.

### **4) count()**

Returns number of elements.

### **5) reduce(...)**

Combines all elements into a single value.
*Ex:* sum of numbers.

### **6) findFirst()**

Returns first element (Optional).

### **7) findAny()**

Returns any element (Optional) (useful in parallel streams).

### **8) anyMatch(Predicate)**

Checks if **any** element matches condition ‚Üí boolean.

### **9) allMatch(Predicate)**

Checks if **all** elements match condition.

### **10) noneMatch(Predicate)**

Checks if **no** element matches condition.

### **11) min(Comparator) / max(Comparator)**

12) sum() to add - calculate all the value

Returns smallest/largest element.

---

## ‚≠ê Super Quick Summary Table

| Operation Type   | Methods                                                       | Purpose                   |
| ---------------- | ------------------------------------------------------------- | ------------------------- |
| **Intermediate** | filter, map, flatMap, sorted, distinct, limit, skip, peek     | Transform or shape stream |
| **Terminal**     | forEach, collect, count, reduce, findFirst, anyMatch, toArray | Produce final result      |


Overall CheatSheet

Quick Cheatsheet (copy/save)

Create: list.stream(), Arrays.stream(arr), Stream.of(...), Files.lines(Path),
Pattern.splitAsStream(), Stream.generate(), Stream.iterate()

Intermediate: filter, map, flatMap, distinct, sorted, limit, skip, peek, mapToInt

Terminal: forEach, collect, reduce, count, findFirst, anyMatch, allMatch, noneMatch, toArray

Collectors: toList(), toSet(), toMap(), groupingBy(), partitioningBy(), joining(), counting()

Primitive: mapToInt, sum, average, min, max, summaryStatistics


Collectors methods explanation:

what is collect

collect is a terminal operation of stream which take Collector object as an argument... below are the
details for the different.

---

# ‚ö° **Collectors Deep Dive ‚Äî Short Notes**

## ‚úÖ **What is a Collector?**

A Collector is an object (from `java.util.stream.Collectors`)
used to **convert a Stream into a different data structure or summary value**.

Used only in **terminal operation**:

```java
stream.collect(Collector)
```

---

# üîπ **1. Collectors.toList()**

### **Purpose**

Collects stream elements into a **List** (ArrayList by default).

### **Usage**

```java
List<String> list = stream.collect(Collectors.toList());
```

### **Notes**

* Allows duplicates
* Maintains insertion order
* Simple and most used

---

# üîπ **2. Collectors.toSet()**

### **Purpose**

Collects stream elements into a **Set**.

### **Usage**

```java
Set<String> set = stream.collect(Collectors.toSet());
```

### **Notes**

* Removes duplicates
* Order is NOT guaranteed (HashSet)

---

# üîπ **3. Collectors.toMap(keyMapper, valueMapper)**

### **Purpose**

Convert stream elements into a **Map** by choosing keys & values.

### **Usage**

```java
Map<K, V> map = stream.collect(
        Collectors.toMap(
                item -> item.getId(),     // keyMapper
                item -> item.getName()    // valueMapper
        )
);
```

### **Notes**

* Throws exception if keys duplicate
* For duplicates ‚Üí use mergeFn (next section)

---

# üîπ **4. Collectors.toMap(keyMapper, valueMapper, mergeFn)**

### **Purpose**

Handles duplicate keys.

### **Usage**

```java
Collectors.toMap(
    keyMapper,
    valueMapper,
    (oldVal, newVal) -> oldVal   // merge function
);
```

### **Notes**

* mergeFn decides how to handle duplicate keys
* mergeFn receives `(oldValue, newValue)`

---

# üîπ **5. Collectors.groupingBy(keyMapper)**

### **Purpose**

Groups data into a **Map<K, List<V>>**.

### **Usage**

```java
Map<String, List<Employee>> map = employees.stream()
        .collect(Collectors.groupingBy(emp -> emp.getDept()));
```

### **Notes**

* Key = group criteria
* Value = list of items in that group
* Most common collector for data grouping

---

# üîπ **6. Collectors.groupingBy(keyMapper, downstreamCollector)**

### **Purpose**

Group data + apply another collector inside group.

### **Example: Count per group**

```java
Collectors.groupingBy(emp -> emp.getDept(), Collectors.counting());
```

### **Notes**

* Makes grouping more powerful
* downstream collectors:

  * counting()
  * summingInt()
  * mapping()
  * toSet(), toList()
  * joining()
  * etc.

---

# üîπ **7. Collectors.partitioningBy(predicate)**

### **Purpose**

Splits elements into **two groups only** ‚Üí TRUE and FALSE.

### **Usage**

```java
Map<Boolean, List<Integer>> result =
        nums.stream().collect(Collectors.partitioningBy(n -> n % 2 == 0));
```

### **Notes**

* Output map always has two keys: `true`, `false`
* Used when condition is binary

---

# üîπ **8. Collectors.joining(delimiter)**

### **Purpose**

Joins strings into one big string with a delimiter.

### **Usage**

```java
String ans = names.stream().collect(Collectors.joining(", "));
```

### **Notes**

* Works only with Stream<String>
* Useful for CSV, display, logs

---

# üîπ **9. Collectors.counting()**

### **Purpose**

Counts number of elements in a group.

### **Usage**

```java
Collectors.groupingBy(key, Collectors.counting());
```

### **Notes**

* Long result
* Used in frequency table

---

# üîπ **Other Useful Collectors**

### **mapping(mapper, downstreamCollector)**

Transform each element before collecting.

```java
Collectors.mapping(emp -> emp.getName(), Collectors.toList())
```

### **summingInt(), summingDouble(), averagingInt()**

Used for numeric summaries.

```java
Collectors.summingInt(emp -> emp.getSalary())
```

### **minBy(), maxBy()**

Find minimum/maximum using comparator.

```java
Collectors.maxBy(Comparator.comparingInt(a -> a))
```

---

# üî• **Quick Interview Revision Sheet**

| Collector               | What it returns       | When to use                         |
| ----------------------- | --------------------- | ----------------------------------- |
| toList()                | List                  | Order preserved, duplicates allowed |
| toSet()                 | Set                   | Remove duplicates                   |
| toMap()                 | Map                   | Key-value output                    |
| groupingBy()            | Map<K, List<V>>       | Group by category                   |
| groupingBy + downstream | Map<K, result>        | Group + summary                     |
| partitioningBy()        | Map<Boolean, List<V>> | True/False split                    |
| joining()               | String                | Combine all strings                 |
| counting()              | Long                  | Count items                         |
