# **Stream API — Short Notes**

* **Stream** is a **wrapper over a data source** (like List, Set, Array, etc.) used for processing data in a pipeline.
* Stream is **not a data structure**; it is only a **view** to process the data.
* Stream is an **Interface** in the `java.util.stream` package.
* Stream **does NOT change the original data source** — it is *non-mutating*.
* Stream supports **functional-style operations** (map, filter, reduce).
* Stream can work in **sequence** or **parallel** (`parallelStream()`).
* Stream is used mostly with **Collections**, Arrays, Files, or any data source.
* Stream operations are of two types:
  ✔ **Intermediate operations** → return a new Stream (lazy)
  ✔ **Terminal operations** → end the Stream and return a result
* Stream uses **lambda expressions + functional interfaces** internally.
* Stream makes code **clean, fast, and more readable**.

Stream Instance/Object Initialization ways - Implemented

Here is the **clean, short, interview-ready note** — **without code** — in the same format you used.
I also added **all possible ways** to initialize a Stream.

---

# **Stream Instance/Object Initialization — Short Notes**

### **1) Using Collection Object**

* Any Collection (List, Set, etc.) can create a Stream using the `stream()` method.

---

### **2) Using Array**

* Arrays can be converted into Streams using `Arrays.stream()`.

---

### **3) Using Stream.of()**

* Directly creates a Stream from one or more values.
* Most commonly used for quick Stream creation.

---

### **4) Using Stream.generate()**

* Creates an **infinite stream** using a **Supplier Functional Interface**.
* Useful for generating repeated or random values.

---

### **5) Using Stream.builder()**

* Uses the **Builder Design Pattern** to add values step-by-step and finally build the Stream.

---

### **6) Creating an Empty Stream**

* Useful when you want a Stream with no elements (placeholder or fallback case).

---

### **7) Using Stream.iterate()**

* Creates a sequential infinite Stream by repeatedly applying a function.
* Useful for series generation (e.g., numbers, patterns).

---

### **8) Using Files.lines()** *(File-based stream)*

* Reads lines of a file as a Stream of Strings.
* Useful in file processing pipelines.

---

### **9) Using Pattern.splitAsStream()** *(String split as stream)*

* Converts a String into a Stream by splitting using a regex pattern.

---

### **10) Using Stream.concat()**

* Combines two Streams into a single Stream.

---

# ⭐ Final Summary (Very Short)

**Ways to Initialize a Stream:**

1. Using Collection (`stream()`)
2. Using Array (`Arrays.stream()`)
3. Using Values (`Stream.of()`)
4. Infinite Stream (`Stream.generate()`)
5. Builder Pattern (`Stream.builder()`)
6. Empty Stream (`Stream.empty()`)
7. Iteration Stream (`Stream.iterate()`)
8. File lines (`Files.lines()`)
9. Regex split (`Pattern.splitAsStream()`)
10. Concatenate Streams (`Stream.concat()`)


Stream Operations

Intermediate operations
Terminal Operations

Intermediate Operations

Intermediate Operations methods on stream always return as another stream object.
In that case we can all multiple intermediate operations on same stream as chain of methods
This is called pipelined on same stream source

Intermediate operations are invoked only once when we invoke terminal operations.

Terminal Operations

We can call only once one terminal method on any stream instance
When we call terminal method we will get the result immediately with all pipelined methods.



